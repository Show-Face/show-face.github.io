---
layout:     post
title:      创建型模式
subtitle:   5个具体模式
date:       2019-08-19
author:     showface
header-img: 
catalog: true
tags:
    - 设计模式
---
创建型模式分为以下几种。  

单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。

原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。

抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。


一、单例模式：  
指一个类只有一个实例，且该类能自行创建这个实例的一种模式。  
单例模式有 3 个特点：  
>单例类只有一个实例对象；  
该单例对象必须由单例类自行创建；  
单例类对外提供一个访问该单例的全局访问点；  


两种实现形式：

>懒汉式单例  
该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。  
注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。
如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。    

>饿汉式单例  
该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。  
饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。  

用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。  
但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。  
在 Java 中 volatile、synchronized 和 final 实现可见性。  
同步技术（sychronized）来让它变成一个原子操作。  

当一个变量定义为 volatile 之后，将具备两种特性：  
1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。  
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。  
volatile 性能：  
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。  


二、原型模式   
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。  

原型模式包含以下主要角色:    
>抽象原型类：规定了具体原型对象必须实现的接口。   
具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。  
访问类：使用具体原型类中的 clone() 方法来复制新的对象。  

用原型模式除了可以生成相同的对象，还可以生成相似的对象  

原型模式通常适用于以下场景:   
对象之间相同或相似，即只是个别的几个属性不同的时候。  
对象的创建过程比较麻烦，但复制比较简单的时候。  


三、工厂方法模式  
定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。  

如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。  
本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

工厂方法模式的主要优点有：  
>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；  
在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；  

>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。  

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。


四、抽象工厂模式  
是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。  

使用抽象工厂模式一般要满足以下条件。  
系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。  
系统一次只可能消费其中某一族产品，即同族的产品一起使用。  

抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下:  
>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。  
当增加一个新的产品族时不需要修改原代码，满足开闭原则。 
 
>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。  

抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。  


五、建造者模式  
建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。  

该模式的主要优点如下：  
>各个具体的建造者相互独立，有利于系统的扩展。  
客户端不必知道产品内部组成的细节，便于控制细节风险。  

>其缺点如下：  
产品的组成部分必须相同，这限制了其使用范围。  
如果产品的内部变化复杂，该模式会增加很多的建造者类。  

建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。  

建造者（Builder）模式由 产品、抽象建造者、具体建造者、指挥者等 4 个要素构成  

建造者（Builder）模式的主要角色如下:  
>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。  
抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。  
具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。  
指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。  













