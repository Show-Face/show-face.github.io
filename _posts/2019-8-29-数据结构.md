---
layout:     post
title:      数据结构
subtitle:   java技巧
date:       2019-08-29
author:     showface
header-img: 
catalog: true
tags:
    - java
---


堆  
堆：堆是一种树，由它实现的优先级队列的插入和删除的时间复杂度都是O(logn)，用堆实现的优先级队列虽然和数组实现相比较删除慢了些，但插入的时间快的多了。  
当速度很重要且有很多插入操作时，可以选择堆来实现优先级队列。

java的堆是程序员用new能得到的计算机内存的可用部分。而数据结构的堆是一种特殊的二叉树。

堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。

堆的逻辑结构是一颗完全二叉树，但物理结构是顺序表(一维数组)。

https://blog.csdn.net/szu_crayon/article/details/81812946

普通堆是子节点父节点的比较

创建最大堆：n   
删掉一个元素：log2n   
删掉全部的元素：n∗log2n   
总的操作次数：n+n∗log2n   
则总的时间复杂度****O(nlogn) 


B树  
树的阶指的是一个结点最多能有多少棵子树。例如：二叉树的阶就是2。

度是基于单个结点的，而阶是针对整棵树的。可以理解为树的阶是用来限制每个结点的度的。

B树，又称B-树，一棵m阶的B树，或为空树，或为满足下列特性的m叉树： 
>（1）树中每个结点至多有m棵子树。【解释：因为树的阶是m，所有这个是必然】   
（2）若根结点不是叶子节点，则至少有两棵子树。   
（3）除根结点之外的所有非叶子结点至少有⌈m/2⌉棵子树。【解释：第一条是用来限制所有节点度的最大值，2、3两条是用来限制根结点和非叶子结点度的最小值】   
（4）所有的非叶子结点关键字的左子树都比它小，右子树都比它大   
（5）所有叶子结点位于同一层  

https://www.cnblogs.com/vincently/p/4526560.html

B+树是对B树的一种变形树，它与B树的差异在于：
>有k个子结点的结点必然有k个关键码；  
非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。  
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

B+ 树的优点在于：
>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。  
B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。  
但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。


https://baishuidongcheng.com/2018/08/11/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%8CB-%E6%A0%91%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%89-Java%E7%89%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E8%A1%A5%E5%85%85/





二叉查找树  
简单来说就是左子树结点值都小于根结点，右子树都大于根结点。

平衡二叉树  
Balanced Binary Tree，又叫AVL树(由提出者名字缩写而来)。简单来说，在二叉查找树的基础上，要保持左右子树高度差不超过1，我们把左子树高度减去右子树高度叫做平衡因子(Balanced Factor,BF)  
二叉查找树查找的时间复杂度最好是O(logn),最坏是O(n)，而AVL最好最坏都是O(logn)，插入和删除也是O(logn)。
  
B减树和B树是一个意思，那个不是减号而是短横。这个不纠结，意思明白就行。  
B树是用于在外存工作的平衡搜索树，MySQL中的索引主要是基于hash表或者B+树。

数据库索引为啥不用二叉查找树实现  
>现实要考虑 磁盘IO。  
数据库索引是存在磁盘上的，因为数据量很大的时候索引大小可能达到几个G。  
因为B树把多个关键字放在了同一个节点中，这样减少了磁盘的IO次数，同时在内存中比较耗时几乎可以忽略，所以只要树高度足够低，IO次数足够少，就能调高查找性能。

每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

https://blog.csdn.net/v_JULY_v/article/details/6530142

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。
B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。
所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

B树：有序数组+平衡多叉树；  
B+树：有序数组链表+平衡多叉树；  
B*树：一棵丰满的B+树。  

R树是B树在高维空间的扩展，是一棵平衡树。  


桶排序（Bucket sort）或所谓的箱排序，是一个排序算法。  
工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。  
桶排序的思想近乎彻底的分治思想。  
高效与否的关键就在于这个映射函数的确定。  
实际使用的时候会根据实际情况采取巧妙的解决办法，比如结合散列表，来提高空间利用率。

哈夫曼树  
带权路径长度最小的树就叫最优二叉树，也就是哈夫曼树。要使带权路径长度最小，那么权值大的点就应该离根节点越近。  
构造方法：先从小到大排序，然后选择最小的两棵树合并，重复这两个步骤。  
哈夫曼编码，让频率高的用短码，频率低的用长码，而且保证不会有某个字符的串是另一个字符的前缀。

https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA  
红黑树  
红黑树的插入、删除、查找最坏时间复杂度都是O(logn)。  
自平衡的二叉查找树。  

>1.节点是红色或黑色。  
2.根节点是黑色。  
3.每个叶子节点都是黑色的空节点（NIL节点）。  
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)  
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

变色，左旋转逆时针，右旋转。  
















































